#HTTPS
##HTTP
HTTP就是我们平时浏览网页时候使用的一种协议。HTTP协议传输的数据都是未加密的，也就是明文的，因此使用HTTP协议传输隐私信息非常不安全。为了保证这些隐私数据能加密传输,于是网景公司设计了SSL（Secure Sockets Layer）协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。
##设计过程
在进行安全设计之初，公司内部调研，讨论出两种方案。而经过验证，以下两种方案被否决。
####方案一
用户提交username + pwd后，服务端返回以下信息：

	

```
{
		"access_token":"2YotnFZFEjr1zCsicMWpAA",
		"expires_in":3600,
		"refresh_token":"tGzv3JOkF0XG5Qx2TlKWIA"
	}
```



access_token 是用来进行访问的接口的，expires_in 是他的过期时间，到达过期时间后，需要用 refresh_token 来请求服务端刷新 access_token。

这里几个重点是：refresh_token 仅能使用一次，使用一次后，将被废弃。另外这个 access_token 只在 expires_in 有效期内有效。

注意： 这里的 expires_in 仅返回秒数就好了。别返回时间戳。因为各个平台计算s的时间戳，不一致，这样子做更方便处理。
####方案二
1. client在开启成功后,会获取到服务器返回的token值, 请将header中的Authorization设置为该值, 服务端以此识别用户, 否则无权操作需要授权的接口;

2. 所有POST请求均需对参数签名 一个合法请求如下:

    

```
{
        "foo": "bar",
        "a": 1,
        "ret": True,
        "ab": 1.2,
        "a1": False,
        "timestamp":1425860757
        "sign": "2455c2db93451999664f7d557f7c0716",
    }

```

   

其中sign具体算法为：

    对除去sign字段的key进行字母排序: ['a', 'a1', 'ab', 'foo', 'ret']

    value为bool类型时转为0或1

    拼接加密字符串: a=1&a1=0&ab=1.2&foo=bar&ret=1&token=asjfjasf

    附加密钥字段: a=1&a1=0&ab=1.2&foo=bar&ret=1&Fr46lwabMP6MNSNtJr3t8HjVNjzIVJeE&timestamp=1425860757

    对上述字符串md5得到sign: 2455c2db93451999664f7d557f7c0716
**注：经过一轮讨论 方案一属于对外做服务的token生成方案 例如微信等 不适合红小宝项目 不予考虑 而https是防止中间人劫持，篡改数据的，那么就不需要sign这个字段 不需要对数据进行加密**



###备注
以上两种方案都是对后续接口访问进行加密，而用户名+密码则是明文传输，需不需要加密呢？经过查询 有人提出用RSA非对称加密进行密码登录验证
具体方案如下：

 ![密码加密方案](http://nmgfrank.com/wp-content/uploads/2015/07/login.png)

 **而HTTPS的原理就是这个：**

 ![](http://upload-images.jianshu.io/upload_images/1430132-d66d71b8bc4c14b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

 而经过调研 例如支付宝，淘宝这样的金融项目 有安全插件检测这一功能 从而防止密码明文丢失问题

 [密码明文](http://blog.csdn.net/attilax/article/details/8003858) HTTPS则是对数据进行加密的 密码明文则不需要加密 
 ###HTTPS原理
 HTTPS(Hyper Text Transfer Protocol Secure)，是一种基于SSL/TLS的HTTP，所有的HTTP数据都是在SSL/TLS协议封装之上进行传输的。HTTPS协议是在HTTP协议的基础上，添加了SSL/TLS握手以及数据加密传输，也属于应用层协议。
 SSL/TLS协议的基本过程是这样的：

1. 客户端向服务器端索要并验证公钥。
2. 双方协商生成“对话密钥”。
3. 双方采用“对话密钥”进行加密通信。
上面过程的前两布，又称为“握手阶段”。
####握手阶段的详细过程

“握手阶段”涉及四次通信，需要注意的是，“握手阶段”的所有通信都是明文的。

#####客户端发出请求（ClientHello）

首先，客户端（通常是浏览器）先向服务器发出加密通信的请求，这被叫做ClientHello请求。在这一步中，客户端主要向服务器提供以下信息：

1. 支持的协议版本，比如TLS 1.0版
2. 一个客户端生成的随机数，稍后用于生成“对话密钥”。
3. 支持的加密方法，比如RSA公钥加密。
4. 支持的压缩方法。

这里需要注意的是，客户端发送的信息之中不包括服务器的域名。也就是说，理论上服务器只能包含一个网站，否则会分不清应用向客户端提供哪一个网站的数字证书。这就是为什么通常一台服务器只能有一张数字证书的原因。

#####服务器回应（ServerHello）

服务器收到客户端请求后，向客户端发出回应，这叫做ServerHello。服务器的回应包含以下内容：

1. 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。
2. 一个服务器生成的随机数，稍后用于生成“对话密钥”。
3. 确认使用的加密方法，比如RSA公钥加密。
4. 服务器证书。

除了上面这些信息，如果服务器需要确认客户端的身份，就会再包含一项请求，要求客户端提供“客户端证书”。比如，金融机构往往只允许认证客户连入自己的网络，就会向正式客户提供USB密钥，里面就包含了一张客户端证书。

#####客户端回应

客户端收到服务器回应以后，首先验证服务器证书。如果证书不是可信机构颁发，或者证书中的域名与实际域名不一致，或者证书已经过期，就会向访问者显示一个警告，由其选择是否还要继续通信。 
如果证书没有问题，客户端就会从证书中取出服务器的公钥。然后，向服务器发送下面三项消息。

1. 一个随机数。该随机数用服务器公钥加密，防止被窃听。
2. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
3. 客户端握手结束通知，表示客户端的握手阶段已经结束。这一项通常也是前面发送的所有内容的hash值，用来供服务器校验。

上面第一项随机数，是整个握手阶段出现的第三个随机数，又称“pre-master key”。有了它以后，客户端和服务器就同时有了三个随机数，接着双方就用事先商定的加密方法，各自生成本次会话所用的同一把“会话密钥”。

#####服务器的最后回应

服务器收到客户端的第三个随机数pre-master key之后，计算生成本次会话所用的“会话密钥”。然后，向客户端最后发送下面信息。

1. 编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。
2. 服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发生的所有内容的hash值，用来供客户端校验。

#####握手结束

至此，整个握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的HTTP协议，只不过用“会话密钥”加密内容。
####一次请求的完整过程
![这里写图片描述](http://img.blog.csdn.net/20170310123918624?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcm9va2llX3NtYWxs/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)